#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <csp/csp.h>
#include <csp/drivers/can_socketcan.h>
#include <csp/drivers/usart.h>
#include <csp/interfaces/csp_if_zmqhub.h>

/* These three functions must be provided in arch specific way */
int router_start(void);
int server_start(void);
int client_start(void);

/* Server port, the port the server listens on for incoming connections from
the
 * client. */
#define MY_SERVER_PORT 10

static uint8_t server_address = 255;

/* test mode, used for verifying that host & client can exchange packets over
 * the loopback interface */
static unsigned int server_received = 0;

/* main - initialization of CSP and start of server/client tasks */
int main() {

  uint8_t address = 0;
#if (CSP_HAVE_LIBSOCKETCAN)
  const char *can_device = NULL;
#endif
  const char *kiss_device = NULL;
#if (CSP_HAVE_LIBZMQ)
  const char *zmq_device = NULL;
#endif
  const char *rtable = NULL;

  csp_print("Initialising CSP");

  /* Init CSP */
  csp_init();

  /* Start router */
  router_start();

  /* Add interface(s) */
  csp_iface_t *default_iface = NULL;
  if (kiss_device) {
    csp_usart_conf_t conf = {.device = kiss_device,
                             .baudrate =
                                 115200, /* supported on all platforms */
                             .databits = 8,
                             .stopbits = 1,
                             .paritysetting = 0,
                             .checkparity = 0};
    int error = csp_usart_open_and_add_kiss_interface(
        &conf, CSP_IF_KISS_DEFAULT_NAME, &default_iface);
    if (error != CSP_ERR_NONE) {
      csp_print("failed to add KISS interface [%s], error: %d\n", kiss_device,
                error);
      exit(1);
    }
  }
#if (CSP_HAVE_LIBSOCKETCAN)
  if (can_device) {
    int error = csp_can_socketcan_open_and_add_interface(
        can_device, CSP_IF_CAN_DEFAULT_NAME, 0, false, &default_iface);
    if (error != CSP_ERR_NONE) {
      csp_print("failed to add CAN interface [%s], error: %d\n", can_device,
                error);
      exit(1);
    }
  }
#endif
#if (CSP_HAVE_LIBZMQ)
  if (zmq_device) {
    int error = csp_zmqhub_init(0, zmq_device, 0, &default_iface);
    if (error != CSP_ERR_NONE) {
      csp_print("failed to add ZMQ interface [%s], error: %d\n", zmq_device,
                error);
      exit(1);
    }
  }
#endif

  if (rtable) {
    int error = csp_rtable_load(rtable);
    if (error < 1) {
      csp_print("csp_rtable_load(%s) failed, error: %d\n", rtable, error);
      exit(1);
    }
  } else if (default_iface) {
    csp_rtable_set(0, 0, default_iface, CSP_NO_VIA_ADDRESS);
  } else {
    /* no interfaces configured - run server and client in process, using
     * loopback interface */
    server_address = address;
  }

  csp_print("Connection table\r\n");
  csp_conn_print_table();

  csp_print("Interfaces\r\n");
  csp_rtable_print();

  csp_print("Route table\r\n");
  csp_iflist_print();

  /* Start server thread */
  if ((server_address ==
       255) || /* no server address specified, I must be server */
      (default_iface == NULL)) { /* no interfaces specified -> run server &
                                    client via loopback */
    server_start();
  }

  /* Start client thread */
  if ((server_address !=
       255) || /* server address specified, I must be client */
      (default_iface == NULL)) { /* no interfaces specified -> run server &
                                    client via loopback */
    client_start();
  }

  /* Wait for execution to end (ctrl+c) */
  while (1) {
    sleep(3);

    if (server_received < 5) {
      csp_print("Server received %u packets\n", server_received);
      exit(1);
    }
    csp_print("Server received %u packets\n", server_received);
    exit(0);
  }

  return 0;
}
